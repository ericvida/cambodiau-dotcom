// node_modules/imba/src/imba/runtime.mjs
var __init__$ = Symbol.for("#__init__");
var __initor__$ = Symbol.for("#__initor__");
var __inited__$ = Symbol.for("#__inited__");
var __hooks__$ = Symbol.for("#__hooks__");
var __patch__$ = Symbol.for("#__patch__");
var __has__$ = Symbol.for("#has");
var __meta__$ = Symbol.for("#meta");
var __imba__$ = Symbol.for("imba");
var __mixin__$ = Symbol.for("#__mixin__");
var matcher = Symbol.for("#matcher");
var L = Symbol.for("#L");
var appendChild$ = Symbol.for("#appendChild");
var afterVisit$ = Symbol.for("#afterVisit");
var beforeReconcile$ = Symbol.for("#beforeReconcile");
var afterReconcile$ = Symbol.for("#afterReconcile");
var up$ = Symbol.for("##up");
var HAS = {
  SUPERCALLS: 1 << 3,
  CONSTRUCTOR: 1 << 4
};
var ClassFlags = {
  IsExtension: 1 << 0,
  IsTag: 1 << 1,
  HasDescriptors: 1 << 2,
  HasSuperCalls: 1 << 3,
  HasConstructor: 1 << 4,
  HasFields: 1 << 5,
  HasMixins: 1 << 6,
  HasInitor: 1 << 7,
  HasDecorators: 1 << 8,
  IsObjectExtension: 1 << 9
};
var mmap = /* @__PURE__ */ new Map();
var state = globalThis[__imba__$] || (globalThis[__imba__$] = {
  counter: 0,
  classes: mmap
});
function meta$(klass, defaults = {}) {
  var _a;
  mmap.has(klass) || mmap.set(klass, {
    symbol: Symbol(klass.name),
    parent: (_a = Object.getPrototypeOf(klass.prototype)) == null ? void 0 : _a.constructor,
    for: klass,
    uses: null,
    inits: null,
    id: state.counter++,
    ...defaults
  });
  return mmap.get(klass);
}
var statics = /* @__PURE__ */ new WeakMap();
function is$(a, b) {
  var _a;
  return a === b || ((_a = b == null ? void 0 : b[matcher]) == null ? void 0 : _a.call(b, a));
}
function isa$(a, b) {
  var _a;
  return typeof b === "string" ? typeof a === b : (_a = b == null ? void 0 : b[Symbol.hasInstance]) == null ? void 0 : _a.call(b, a);
}
function has$(a, b) {
  var _a, _b, _c;
  return ((_a = b == null ? void 0 : b[__has__$]) == null ? void 0 : _a.call(b, a)) ?? ((_b = b == null ? void 0 : b.includes) == null ? void 0 : _b.call(b, a)) ?? ((_c = b == null ? void 0 : b.has) == null ? void 0 : _c.call(b, a)) ?? false;
}
function idx$(a, b) {
  return (b == null ? void 0 : b.indexOf) ? b.indexOf(a) : Array.prototype.indexOf.call(a, b);
}
function devlog$(args, self, ...rest) {
  if (self && self[L] instanceof Function) args = self[L](args, self, ...rest);
  else if (globalThis[L] instanceof Function) args = globalThis[L](args, self, ...rest);
  return args;
}
function statics$(scope) {
  return statics.get(scope) || statics.set(scope, {}).get(scope);
}
function iterable$(a) {
  var _a;
  return ((_a = a == null ? void 0 : a.toIterable) == null ? void 0 : _a.call(a)) || a;
}
function decorate$(ds, t, k, desc) {
  let d, c = arguments.length, i = ds.length;
  let r = c < 3 ? t : desc === null ? desc = Object.getOwnPropertyDescriptor(t, k) : desc;
  while (i > 0) {
    if (d = ds[--i]) {
      r = (c < 3 ? d(r) : c > 3 ? d(t, k, r) : d(t, k)) || r;
    }
    ;
  }
  ;
  c > 3 && r && Object.defineProperty(t, k, r);
  return r;
}
function isSameDesc(a, b) {
  if (!a || !b) return false;
  if (a.get) return b.get === a.get;
  if (a.set) return b.set === a.set;
  if (a.value) return a.value === b.value;
}
function extend$(target, ext, descs, cache = {}) {
  const klass = target.constructor;
  if (!descs && ext) {
    descs = Object.getOwnPropertyDescriptors(ext);
    delete descs.constructor;
    if (descs[__init__$]) {
      console.warn(`Cannot define plain fields when extending class ${klass.name}`);
      delete descs[__init__$];
    }
    ;
  }
  let meta = meta$(klass);
  if (meta && meta.augments) {
    const map = /* @__PURE__ */ new Map();
    for (let key of Object.keys(descs)) {
      let orig = Object.getOwnPropertyDescriptor(target, key);
      for (let augmented of meta.augments) {
        let defines = map.get(augmented);
        defines || map.set(augmented, defines = {});
        let augmentedKey = Object.getOwnPropertyDescriptor(augmented.prototype, key);
        if (augmentedKey && !isSameDesc(orig, augmentedKey)) console.warn("wont extend", key, augmentedKey, orig);
        else defines[key] = descs[key];
      }
    }
    for (let [augmented, defines] of map) {
      if (Object.keys(defines).length) extend$(augmented.prototype, null, defines);
    }
  }
  Object.defineProperties(target, descs);
  return target;
}
function augment$(klass, mixin) {
  let meta = meta$(klass);
  let mix = meta$(mixin);
  if (mix.parent) {
    if (!(klass.prototype instanceof mix.parent)) {
      throw new Error(`Mixin ${mixin.name} has superclass not present in target class`);
    }
  }
  if (!mix.augments) {
    mix.augments = /* @__PURE__ */ new Set();
    const ref = mix.ref = Symbol(mixin.name);
    const native = Object[Symbol.hasInstance];
    mixin.prototype[ref] = true;
    Object.defineProperty(mixin, Symbol.hasInstance, {
      value: function(rel) {
        return this === mixin ? rel && !!rel[ref] : native.call(this, rel);
      }
    });
  }
  if (klass.prototype[mix.ref]) {
    return klass;
  }
  if (mix.uses) {
    for (let v of mix.uses) augment$(klass, v);
  }
  mix.augments.add(klass);
  meta.uses || (meta.uses = []);
  meta.uses.push(mixin);
  let descs = Object.getOwnPropertyDescriptors(mixin.prototype);
  delete descs.constructor;
  if (descs[__init__$]) {
    meta.inits || (meta.inits = []);
    meta.inits.push(mixin.prototype[__init__$]);
    delete descs[__init__$];
  }
  Object.defineProperties(klass.prototype, descs);
  if ((mixin == null ? void 0 : mixin.mixed) instanceof Function) mixin.mixed(klass);
  return klass;
}
function multi$(symbol, sup2, ...mixins) {
  let Mixins = sup2 ? class extends sup2 {
  } : class {
  };
  let meta = meta$(Mixins, { symbol });
  for (let mixin of mixins) augment$(Mixins, mixin);
  Mixins.prototype[symbol] = function(o, deep, fields) {
    if (meta.inits)
      for (let init of meta.inits) {
        init.call(this, o, false, fields);
      }
    return;
  };
  return Mixins;
}
var sup = {
  cache: {},
  self: null,
  target: null,
  proxy: new Proxy({}, {
    apply: (_, key, ...params) => {
      return sup.target[key].apply(sup.self, params);
    },
    get: (_, key) => {
      return Reflect.get(sup.target, key, sup.self);
    },
    set: (_, key, value, receiver) => {
      return Reflect.set(sup.target, key, value, sup.self);
    }
  })
};
function sup$(self, symbol) {
  sup.self = self;
  sup.target = sup.cache[symbol];
  return sup.proxy;
}
function register$(klass, symbol, name, flags, into = null) {
  var _a;
  let proto = Object.getPrototypeOf(klass.prototype);
  let mixed = flags & ClassFlags.HasMixins;
  let meta;
  if (mixed) {
    mmap.set(klass, mmap.get(proto.constructor));
    proto = Object.getPrototypeOf(proto);
  }
  if (into) {
    let target = flags & ClassFlags.IsObjectExtension ? into : into.prototype;
    let meta2 = meta$(klass);
    if (meta2.uses) {
      if (into === target) console.warn("Cannot extend object with mixins");
      for (let mixin of meta2.uses) augment$(into, mixin);
    }
    if (flags & ClassFlags.HasSuperCalls) {
      sup.cache[symbol] = Object.create(
        Object.getPrototypeOf(target),
        Object.getOwnPropertyDescriptors(target)
      );
    }
    extend$(target, klass.prototype);
    return into;
  }
  let supr = proto == null ? void 0 : proto.constructor;
  meta = meta$(klass, { symbol });
  Object.defineProperty(klass, __meta__$, { value: meta, enumerable: false, configurable: true });
  if (name && klass.name !== name) {
    Object.defineProperty(klass, "name", { value: name, configurable: true });
  }
  meta.flags = flags;
  if (flags & ClassFlags.HasConstructor)
    klass.prototype[__initor__$] = symbol;
  if (meta.uses) for (let mixin of meta.uses) (_a = mixin.mixes) == null ? void 0 : _a.call(mixin, klass);
  if ((supr == null ? void 0 : supr.inherited) instanceof Function) supr.inherited(klass);
  return klass;
}
function inited$(obj, symbol) {
  var _a;
  if (obj[__initor__$] === symbol) {
    (_a = obj[__inited__$]) == null ? void 0 : _a.call(obj);
    obj[__hooks__$] && obj[__hooks__$].inited(obj);
  }
}
export {
  ClassFlags,
  HAS,
  __has__$,
  __hooks__$,
  __imba__$,
  __init__$,
  __inited__$,
  __initor__$,
  __meta__$,
  __mixin__$,
  __patch__$,
  afterReconcile$,
  afterVisit$,
  appendChild$,
  augment$,
  beforeReconcile$,
  decorate$,
  devlog$,
  extend$,
  has$,
  idx$,
  inited$,
  is$,
  isa$,
  iterable$,
  matcher,
  multi$,
  register$,
  statics$,
  sup$,
  up$
};
//# sourceMappingURL=imba_runtime.js.map
